---
title: 資料密集型系統設計-交易
description: 資料密集型系統設計-交易
slug: data-intensive-systems-design-transaction
date: 2026-02-17
type: Post
---

## 前言
<p>對於資工系本科的人來說，交易這件事情應該不會陌生，最常聽到的就是ACID原則，他是指我們在資料庫的操作上，安全保證上我們所會運用的特性。</p>
<p>因為有別於一般的資料庫操作，交易需要具備ACID原則，才能確保資料的一致性和可靠性。</p>

## ACID 原則
<h3>原子性（Atomicity）</h3>
<p>是指一個交易要麼完全成功，要麼完全失敗，不會有中間狀態。這確保了資料的一致性，避免了部分更新導致的資料不完整或錯誤。</p>
<h3>一致性（Consistency）</h3>
<p>是指交易在執行前後，資料庫的狀態必須保持一致。這意味著交易必須遵守資料庫的約束條件和規則，確保資料的完整性和正確性。</p>
<h3>隔離性（Isolation）</h3>
<p>是指同時執行的交易之間不會互相干擾。每個交易應該像是獨立運行的，確保了資料的一致性和正確性。</p>
<h3>持久性（Durability）</h3>
<p>是指一旦交易完成，對資料庫的修改將永久保存在資料庫中，即使系統崩潰也不會丟失。這確保了資料的可靠性和持久性。</p>
<h2><b>原子性、隔離性跟持久性是資料庫的屬性，通常在底層 資料庫會自己幫我們處理好，但是一致性是應用程式的特性，也就是說，這個特質會是我們自己在設計程式時要自己處理好的</b></h2>

## 交易的錯誤場景
<h3>髒讀（Dirty Read）</h3>
<p>當一個交易讀取了另一個尚未提交的交易所修改的資料，這種情況稱為髒讀。這可能導致資料不一致，因為如果第二個交易最終回滾，那麼第一個交易讀取的資料就會變得無效。</p>
<p>舉個例子 我們有一個商品需要先被認領之後才可以花錢充值，他在認領時，資料庫已經先把他標示為認領，但可能後續有些狀態是失敗的，所以在前端看時，他已經是認領完，所以他就花錢充值。</p>
<p>在實際上，他被標示為認領，但其實他是失敗的。但我們後續的充值行為，卻已經假設他已經是正常的認領狀態而允許</p>
<p>這就是髒讀最嚴重所造成的 「因為假數據所造成的錯誤決策」。</p>

<h3>髒寫（Dirty Write）</h3>
<p>假設我們有一個操作同時要改到訂單資料跟發票資料，使用者a跟使用者b都對同一筆訂單進行了編輯的動作，訂單修改順序是a先b後，而發票的修改順序則是b先a後。</p>
<p>那就以結果來說，訂單的最後編輯者是b，但發票則是a。這就是髒寫所造成的不一致。</p>

<h3>不可重複讀（Non-repeatable Read）</h3>
<p>當一個交易在執行期間多次讀取同一筆資料，但每次讀取的結果可能不同，這種情況稱為不可重複讀。這可能導致資料不一致，因為如果第二個交易修改了該資料，那麼第一個交易在後續的讀取中就會得到不同的結果。</p>
<p>假設有一個紀錄信箱未讀數量的一個功能，但我發現要去計算未讀數量的這個操作要花太久時間了，於是我打算另外拉一個欄位(unread_number)來加速查詢，但也就代表 資料的更新跟這個數字的更新彼此會存在時間差</p>
<p>而髒讀就是指，當我select未讀信件時，我有找到一筆尚未讀取的信件，但是卻還沒有更新到unread_number，所以會造成，實際有未讀信件，但是數字卻存在0的誤差，這就是違反了隔離性的原則。</p>

<h3>幻讀（Phantom Read）</h3> 
<p>當一個交易在執行期間多次讀取同一筆資料，但每次讀取的結果可能不同，這種情況稱為幻讀。這可能導致資料不一致，因為如果第二個交易插入了新的資料，那麼第一個交易在後續的讀取中就會得到不同的結果。</p>
<p>跟不可重複讀的差別在於，不可重複讀是指同一筆資料被修改了，而幻讀則是指有新的資料被插入了。</p>
<p>所以幻讀的影響範圍是全域的資料，而不可重複讀則是特定區間</p>

## 隔離級別
<p>在軟體設計的角度來講，越高級的安全性需要拿越多的時間跟運算資源來保證。因此在資料庫中，隔離級別的選擇是一個權衡的問題。弱隔離級別允許交易之間存在一些不一致的情況，但可以提高系統的性能和吞吐量。強隔離級別則提供更高的安全性，但就會降低系統的性能和吞吐量。</p>
<p>在資料庫中，隔離級別定義了交易之間的隔離程度。弱隔離級別允許交易之間存在一些不一致的情況，例如髒讀、不可重複讀和幻讀等。這些不一致的情況可能會導致資料的錯誤和不可靠。</p>
<h3>Read Uncommitted (讀取未提交)</h3>
<p>這是最弱的隔離級別，允許交易讀取其他交易尚未提交的資料。這可能導致髒讀、不可重複讀和幻讀等不一致的情況。</p>
<h3>Read Committed (讀取已提交)</h3>
<p>這是較弱的隔離級別，允許交易讀取其他交易已經提交的資料。這可以避免髒讀，但仍然可能導致不可重複讀和幻讀等不一致的情況。</p>
<h3>Repeatable Read (可重複讀)</h3>
<p>這是較強的隔離級別，允許交易在執行期間多次讀取同一筆資料，但每次讀取的結果可能不同。這可以避免髒讀和不可重複讀，但仍然可能導致幻讀等不一致的情況。</p>

## Race Condition
<p>競爭條件是指當多個交易同時訪問和修改同一筆資料時，可能會導致資料不一致的情況。這是因為交易之間的執行順序可能會影響到資料的最終狀態。</p>
<p>例如，假設有兩個交易同時訪問和修改同一筆訂單資料。交易A先讀取了訂單資料，然後進行了一些修改，但尚未提交。交易B也讀取了同一筆訂單資料，並進行了一些修改，但尚未提交。這時，如果交易A先提交了修改，那麼交易B的修改就會基於舊的資料進行，導致資料不一致的情況。</p>
<p>為了避免競爭條件，資料庫通常會使用鎖定機制來確保交易之間的隔離性。這可以防止多個交易同時訪問和修改同一筆資料，從而確保資料的一致性和可靠性。</p>
<h3>原子操作（Atomic Operations）</h3>
<p>不要先讀再改，直接讓資料庫做：UPDATE stock SET count = count - 1 WHERE id = 1。避免同樣的操作，但卻得到一樣的結果</p>
<h3>悲觀鎖（Pessimistic Locking）</h3>
<p>悲觀鎖是一種鎖定機制，當一個交易訪問和修改一筆資料時，它會鎖定該資料，直到交易完成。這可以確保其他交易無法同時訪問和修改該資料，從而避免競爭條件的發生。</p>
<h3>樂觀鎖（Optimistic Locking）</h3>
<p>樂觀鎖是一種鎖定機制，當一個交易訪問和修改一筆資料時，它不會鎖定該資料，而是使用版本號或時間戳等方式來檢查資料是否被其他交易修改過。</p>

## 結語
<p>有別於一般的資料庫操作，交易這件事情在資料庫的設計上多了一些條件跟元素，需要具備ACID的特性，也需要在設計時更多的考慮不同的情況。是個有趣的場景，但拆的更細微來看，其實他也就是不同的取捨間，選擇更符合商業跟系統需求的選擇，了解需求的緊急程度、知道手上資源的運用跟稀缺，做出符合需求的設計，而不是一味的追求最高的安全，這才是最適合跟成熟的資料庫設計。</p>