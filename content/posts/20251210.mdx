---
title: 資料庫的守門員：redis
description: 資料庫緩存與及利弊
slug: database-guardian-redis
date: 2025-12-10
type: Post
---

## 前言
<p>資料庫，一個後端不可缺少的技能之一，其實綜觀整個平臺服務裡面，現在已經有很多避免資料庫被過量請求淹沒的機制了，從最前端的sessionStorage、CDN、再到後端的API Gateway、Cache、水平垂直擴容等等方式，都是為了讓資料庫可以更穩定的運作。其中緩存(Cache)是一個非常重要的角色。</p>

<p>首先cache使一個非常廣泛的概念，它可以存在於前端、後端、資料庫等等地方，簡單來說就是將常用的資料放在一個比較快的地方，讓系統可以更快的存取這些資料。</p>
<p>在前端的話，可能叫做sessionStorage或localStorage，甚至瀏覽器自己也有針對路徑跟圖片去做cache。</p>
<p>在伺服器端，可以是CDN，像是Cloudflare、Akamai等等，這些都是將靜態資源放在離使用者更近的地方，讓使用者可以更快的存取這些資源。</p>
<p>而在資料庫端，cache通常是指將常用的資料放在記憶體中，讓系統可以更快的存取這些資料，而不需要每次都去資料庫查詢。</p>
<p>而今天討埨的就是在資料庫端最常被使用的緩存：Redis</p>

## 什麼是Redis？

<p>先來看看網路上是怎麼定義的</p>
<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>
<p>簡單來說，Redis是一個基於記憶體的資料庫，可以用來存取各種資料結構，並且支援高可用性與分區。</p>
<p>而他的快速正是因為他是基於記憶體的，記憶體的存取速度遠遠快於硬碟，所以可以大幅提升資料的存取速度。</p>
<p>雖然他是存在記憶體內，但其實現在大部分的服務都會透過一些小手段來實現持久化或是一制性。比如Amazon ElastiCache的服務就可以搭配EC2來做到機器關機重啟後還是保存redis的資料</p>

## Redis的資料型態
<p>Redis支援多種資料型態，以下是幾個常見的資料型態：</p>
<p>1. 字串(String)：最基本的資料型態，可以存放任何類型的資料，比如文字、數字、圖片等等。</p>
<p>2. 列表(List)：可以存放有序的資料集合，可以用來實現佇列、堆疊等等資料結構。</p>
<p>3. 集合(Set)：可以存放無序的資料集合，可以用來實現標籤、分類等等資料結構。</p>
<p>4. 有序集合(Sorted Set)：可以存放有序的資料集合，並且可以根據分數來排序，可以用來實現排行榜、優先佇列等等資料結構。</p>
<p>5. 哈希(Hash)：可以存放鍵值對的資料集合，可以用來實現物件、字典等等資料結構。</p>
<p>以上五種是官方網站列出的資料型態，而實務上也有一些延伸的資料型態，比如位圖(Bitmap)、HyperLogLog、地理空間(Geospatial)等等。</p>
<p>這些資料型態可以滿足大部分的應用開發，而且也可以針對資料設定ttl(time to live)，讓資料可以自動過期，這對於緩存來說是非常重要的功能。</p>

## 緩存缺點
<p>雖然緩存可以減緩資料庫的負擔，但是在某些場景下，仍然還是會發生資料庫崩潰的情形，簡單來說 就是守門員沒有把球手好的概念xD。</p>
<h3>快取雪崩 (Cache Avalanche, 緩存雪崩)</h3>
<p>" 什麼是快取雪崩 ? "</p>
<p>在某個時刻所有的 cache同時發生過期或者redis 服務失效，導致大量的 request 因為讀不到快取，所以向資料庫請求，而當大量請求直接湧向資料庫，這樣的狀況就是快取雪崩。</p>

<p>解決方案 -</p>
<p>因為是同個時間點，所有的cache key大規模失效，因此可以在設定 cache 時，給予每個cache key 隨機的過期時間。每個cache key 過期時間的設定，其核心理念在你想要更新資料的頻率。</p>

<h3>快取擊穿 (Hotspot Invalid, 緩存擊穿)</h3>
<p>" 什麼是快取擊穿 ? “</p>
<p>快取擊穿和快取雪崩相似，雪崩是大面積cache key時間過期，而快取擊穿則是某個熱門的 cache key過期。所以，當高併發集中在此熱門的key又快取失效過期時，流量就會直接打在資料庫上，這樣子的狀況就叫快取擊穿。</p>

<p>解決方案 -</p>
<p>要避免快取擊穿其中一個方法是將熱點key設為不過期，另一個方法則是在application寫lock(互斥鎖)以確保共用資源在多執行緒下可以排隊拿取資源，不過此作法會造成系統吞吐量下降，並阻礙其他線程。</p>

<h3>快取穿透 (Cache Penetration, 緩存穿透)</h3>
<p>" 什麼是快取穿透 ? “</p>
<p>快取穿透是指client request 的資料並不存在於 cache 中並且也不存在於資料庫中，因此每次的請求就會直接穿過cache並打在資料庫中。同樣，若這樣類行的請求量一多，也是會將資料庫打掛。</p>
<p>舉個簡單的例子，若 client 請求 id=-1的資料，但是在我們的資料庫中是從id =1開始的流水號，那麼-1則永遠不會拿到資料，並且請求會直接打在資料庫上。</p>

<p>解決方案 -</p>
<p>因為是查找不存在的資料，因此可以在application中過濾非法請求，也就是當client 請求id = -1時，直接將請求做例外處理，不要讓他打在資料庫上。另一種方式，則是將id=-1寫入cache中並回傳對應的處理，例如當id=-1則redis則回傳null。還有另一種方式則是使用 " 布隆過濾器 "(Bloom Filter)判斷請求的key是否存在於集合中，若存在則直接去redis拿取，若不在則直接回傳對應訊息。</p>

## 開發上的使用心得

<p>redis是一個非常被廣泛使用的快取機制，像是在我們在使用上，就利用了他的地理位置的特性，實現找某一個定點附近的交通站點，這件事情就是sql在原本的結構下非常難做到的
    除此之外，他也確實大幅減少了我們資料庫的負擔，讓系統可以更穩定的運作。</p>
<p>但是！就像是所有服務共有的特性在取捨上 就代表一筆資料可能存在在快取跟資料庫中，而在不同的情境，會決定快取才是正確的，還是資料庫才是正確的</p>
<p>像是在我的之前的文章有提到紀錄系統的開發，我們就是透過redis來做為緩存，讓使用者可以快速紀錄，而我們在晚上的時候，才把這些資料寫入db，這就是快取權重高於資料庫的例子</p>
<p>另外在開發時，也需要注意當某些操作出現時，會需要重新建立其影響的cache，才能即時更新使用者資訊</p>