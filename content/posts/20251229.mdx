---
title: 資料庫搜索方式：btree && b+tree
description: 資料庫索引結構介紹
slug: database-search-btree-bplus-tree
date: 2025-12-29
type: Post
---

## 前言
<p>加入後端組也快滿一年的時間了，資料庫是一個我們每天都在碰的東西，
    雖然在工作上我們可能初期只會用到最基本的CRUD操作，頂多在程式碼的撰寫上避免N+1查詢等等，但隨著開發經驗的累積，
    下一階段還是會碰到table的設計跟索引，而這邊如果不知道他底層的搜尋方式，那麼在設計上就會設計出沒有效率或是不符合需求的table跟index。</p>
<p>所以這邊簡單整理了一下資料庫在搜索時所用到的資料結構B+tree，以及當我們在建立table時，我們選擇建立index時，背後的ORM實際上做了哪些事情</p>

## B-Tree和B+Tree？
<p>在資料庫的索引結構中，B-Tree跟B+Tree是兩種常見的資料結構，他們都是一種平衡樹，主要用來提高資料的搜尋效率。</p>
<p>B-Tree（Balanced Tree）是一種自平衡的樹狀資料結構，。B-Tree的每個節點可以有多個子節點，並且每個節點都包含多個鍵值。</p>
<p>B+Tree則是B-Tree的一種變體，主要區別在於B+Tree的所有資料都存儲在葉子節點中，而非內部節點。</p>

## BTree
<p>跟過去的二元搜尋樹(Binary Search Tree)不同，B-Tree允許每個節點有多個子節點，這樣可以減少樹的高度，從而提高搜尋效率。</p>
<p>B-Tree的每個節點包含以下特點：</p>
<p>1. 節點可以有多個鍵值，這些鍵值是有序的。</p>
<p>2. 節點可以有多個子節點，子節點的數量比鍵值的數量多一個。</p>
<p>3. 所有葉子節點都在同一層，這樣可以確保搜尋操作的時間複雜度為O(log n)。</p>
<p>由於每個節點都包含資料本身，所以在固定大小的節點中，B-Tree相較於B+Tree儲存更少的索引，有可能會增加數的高度，提升查找的時間跟速度變慢。</p>

## B+Tree
<p>特點：非葉節點不存資料，所以查找速度固定是O(logN)</p>
<p>1. 所有資料都存儲在葉子節點中，內部節點只存儲鍵值和指向子節點的指標。</p>
<p>2. 葉子節點之間通過指標相互連接，形成一個鏈表，這樣可以支持範圍查詢。</p>

## 為什麼B+Tree更適合資料庫索引？
<p>1. 節點利用率更高：由於B+Tree的內部節點不存儲資料，可以存儲更多的鍵值，這樣可以減少樹的高度，提高搜尋效率。</p>
<p>2. 範圍查詢效率高：B+Tree的葉子節點之間通過指標相互連接，不需要像是B tree還需要從頭查起，減少IO</p>

## 資料庫為什麼要設定索引?
<p>假設我們有一個 table ，並且我們想要查找特定條件下的紀錄。資料庫在查找的過程中，可能會遍歷整個表格來找到符合條件的資料，這個過程稱為全表掃描（Full Table Scan）。這樣的方式在資料量很小的時候你會覺得速度沒有差很多，但如果你的 table 是幾千萬筆的超大型 table，查詢時間可能會變得非常長。
這種查找方式的時間複雜度為 O(n)，也就是與資料表的大小成正比。隨著資料表中紀錄的數量增加，查詢時間會變得越來越長。</p>

## 設定索引時發生了什麼事？ 
<p>其實就像剛剛講的，索引就像在完整的資料中，加入一個 linked list 或 B+Tree 結構，方便快速查找。</p>
<p>舉個例子最快理解，假設我們把 `score` 設成 index，我們要找分數 85 分的學生。</p> 
<p>從 root 節點開始，首先比較 80 分（root 節點的值）和目標分數 85，由於 85 > 80，我們進入右邊子節點 90 分。</p>
<p>接著比較 90 和 85，最後進到左子節點找到 85 分的學生資料。</p>
<p>這樣的搜尋方法有點類似 Binary Search，時間複雜度由 Full Table Scan 的 O(N) -> O(log N)。</p>
<p>所以當我們在建立索引時，其實不會改變原有的tree結構，他只是在資料儲存的位置(B tree就是節點本身，B+tree則是葉節點)，增加一個linked list，使查找時，能夠快速定位到下一個相信的資料並回傳</p>

## 建立索引的注意事項
<p>選擇適當的欄位：選擇經常用於查詢、過濾或排序的欄位來建立索引。</p>
<p>避免過多的索引：每個索引都會佔用額外的儲存空間，並且在資料插入、更新或刪除時會增加額外的維護成本。</p>