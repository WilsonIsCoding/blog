---
title: 資料密集型系統設計：複製副本
description: 資料密集型系統設計讀書分享
slug: data-intensive-systems-design-replication
date: 2025-12-03
type: Post
---

## 前言

<p>
  在我自己的部落格裡面鮮少提及到關於資料庫的內容，有一部分原因是因為去年還在當前端工程師，除了讀書會以外
  真的不太
  有碰到資料庫的時間，另外一個就是自己轉到後端組之後，需要惡補一些常識性的東西，那些我覺得對於非常基礎的東西，感覺寫出來
  有點矯情xD，所以就乾脆就不寫了，直到最近在看資料密集型系統設計這本書的時候，覺得有一種
  歐～原來資料庫的世界是這樣的感覺。
</p>

## 資料副本？

<p>
  在一個分散式的系統裡面，通常會將一個服務拆成多台的機器，用來提高系統的可用性。不論是伺服器或是資料庫
  都可以用這樣的概念來進行擴展。
</p>

<p>
  但在軟體的世界裡面，一切都是取捨！當我們選擇可用性時，另外一個議題就延伸而出，那就是資料一致性，如果今天處理的資料不會隨著時間改變，那我們可以很放心地複製過去，事情很容易就完成
</p>

<p>
  資料庫與伺服器不一樣，大多時候資料庫是「有狀態」的，伺服器掛掉之後就重開，就可以繼續服務，但是資料庫一旦掛掉，如果沒有好的退場跟同步機制，那使用者的資料可能就會遺失。
</p>

<p>
  「事情可能出錯與不可能出錯的差別在於，不可出錯的事情一旦出錯，就意味著事情無法挽回了。」
</p>

## single-leader replication(單領導複製)

<p>
  單領導複製也叫做主從複製，這是最常見的複製方式，通常會有一個主節點(leader)負責處理所有的寫入請求，然後將資料複製到多個從節點(follower)，這些從節點則負責處理讀取請求。
</p>
<p>
  而在這種架構下，寫入操作會先在主節點上進行，然後再將資料複製到從節點。這樣的設計可以確保資料的一致性，因為所有的寫入操作都會先在主節點上進行。
</p>

<h3>同步方式</h3>
<p>1.同步複製：在這種方式下，主節點在確認寫入操作完成之前，會等待所有從節點都確認收到資料。這樣可以確保資料的一致性，但會增加寫入操作的延遲。
    但通常實務上不會使用這種方式，因為就像是燈泡的串連一樣，一個掛了 全部人都在等你。</p>
<p>2.半同步複製：概念差不多，只不過是只要等一個人通過就算通過了</p>
<p>3.完全不同步複製：在這種方式下，主節點在寫入操作完成後，會立即回應客戶端，而不會等待從節點的確認。</p>

<h3>leader failure</h3>
<p>當主節點發生故障時，系統需要有一個機制來選舉新的主節點。</p>
<p>這中間會經過幾個流程：</p>
<p>1.確定leader真的失聯了</p>
<p>2.選出新的leader</p>
<p>
  3.重新將寫入請求交給新leader，並讓他其他節點知道他是新的leader，可以接受他的寫入請求
</p>

<h3>複製落後</h3>
<p>
  就像是剛剛講的，當我們有多個資料庫需要進行同步時，可能會發生leader資料庫還沒有向follower同步完成的情況，這時候如果有讀取請求到達follower，可能會讀取到舊的資料。
</p>
<p>
  而在現實上，這個延後可能是幾毫秒，幾秒鐘，甚至就漏掉更新這些情況都有可能發生。不僅如此，不同的請求可能會被分散到不同的伺服器中，有些更新好的，有些還沒，這會導致使用者
  可能在留言區重新刷新了一次，卻發現留言變少了的困惑
</p>
<p>而處理方式有兩個：</p>
<p>
  1.讀取自己的寫入：有一個方法可以使用，就是使用者在sever上讀取自己的資料，並在follower上讀取別人的資料，但這其實是鑽了使用者不能修改其他使用者的資訊的空，原有的資料落後問題還是存在;
  或者是在請求上標記一個客戶最近執行的時間戳，如果這個時間戳比follower的資料更新，那就去leader讀取最新的資料。
</p>
<p>
  2.單調讀取：這概念感覺蠻像是使用者版的db
  sharding，我們一樣會針對使用者有做分類，a使用者的請求固定導入到A
  DB，這樣就可以避免同一個使用者在兩次相同的請求下拿到不同的response。
</p>

## multi-leader replication(多領導複製)

<p>
  先看一下定義：多領導複製是指在一個分散式系統中，有多個節點可以同時處理寫入請求，這些節點之間會進行資料同步，以確保資料的一致性。
</p>
<p>
  而通常在實務上，會用在跨資料中心的情境下，因為如果只有單一leader的話，當使用者在不同地區存取資料時，可能會因為網路延遲而導致寫入操作變慢。
</p>
<p>
  好處是可以提高系統的可用性，因為即使其中一個leader發生故障，其他leader仍然可以繼續處理寫入請求。
</p>
<p>
  但缺點是資料一致性較難維護，因為多個leader可能會同時處理寫入請求，導致資料衝突的情況發生。
</p>

## 更新方式

<p>拓墣是書中提到更新leader的方式：</p>
<p>
  在這種方式下，當一個leader收到寫入請求時，會立即將資料同步到其他leader。這樣可以確保資料的一致性，但會增加寫入操作的延遲。這個跟其他leader的互動方式還分為不同形狀的
  拓墣
</p>

<p>
  舉例來說，兩個人同時在編輯同一個頁面的內容，這時候就會發生衝突，系統需要有一個機制來解決這些衝突。(在看到這邊的時候想起git
  的 conflict)
</p>
<p>而就像是git 一樣，同樣都是leader的指令，也都還會面對到解衝的過程</p>
<p>衝突管理</p>
<p>
  1.最後寫入勝出(last write
  wins)：這種方式是指當發生衝突時，系統會選擇最後一個寫入的資料作為最終的資料。這種方式簡單易行，但可能會導致資料遺失的情況發生。
</p>
<p>
  2.合併資料(merge
  changes)：這種方式是指當發生衝突時，系統會嘗試將不同的資料進行合併，以產生一個新的資料版本。這種方式可以保留更多的資料，但可能會導致資料不如預期的情況發生。
</p>

## leaderless replication(無領導複製)
<p>在剛剛的例子裡面，通常是使用者會對leader進行寫入操作，但在無領導複製的架構下，使用者會「同時」所有的節點發起寫入請求。並透過讀取的過程來修正其他的節點正確值應該是多少。</p>

<h3>衝突管理</h3>
<p>舉例來說，使用者在發出請求時，會對a、b、c都進行寫入操作，但是c卻失敗了，然後在讀取的過程中，也會同時讀a、b、c ，在發現c的回應不一致時，會將失敗操作再執行一次，也就是所謂的利用讀取來修正。</p>
<p>另外一種方式，就是反熵程序，就是資料背景程式中會有一個不斷尋找節點差異的守門員定期補上缺少的日誌</p>
